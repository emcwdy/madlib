# coding=utf-8
"""
@file  utility.py_in
@brief These functions are used as utilities.
       Some of them are written in python, and 
       some of them are written by invoking 
       udfs which are written in c.
"""

import plpy


def __get_query_value(t, key, i = 0):
    """
    @brief If the ith record which is a dict exists and the dict has the param 
           key, return the value of the key, or return None.

    @param t     The result getting from plpy.execute(sql), which
                 is a list of dicts. 
    @param key   The keyword in the ith dict.
    @param i     The index of ith record in t, default value is 0. 
    
    @return      The value of the keyword in the ith record. 
    """
    if t is not None and t.nrows() > 0 :
        return t[i][key]
    else :
        return None


def __get_query_record(t, i = 0):
    """
    @brief Get the ith record from t.

    @param t    The result getting from plpy.execute(sql)
    @param i    The index of ith record in t, default value is 0.
    """
    if t is not None and t.nrows() > 0 :
        return t[i]
    else :
        return None


def __coalesce(content, value):
    """
    @brief If the content is None, return the value, or return the content 
           itself.
    
    @param content    The text.
    @param value      The replace text, if the content is None.
    """ 
    if content is None :
        return value
    else :
        return content


def __str_to_sql(content):
    """
    @brief Format a str into sql. If the content is None, return null, 
           or return the content with escape '.
    
    @param content    The text.
    @param value      The replace text, if the content is None.
    """
    if content is None :
        return "null"
    else :
        return "'{text}'".format(text = content)


def __list_to_sql(list):
    """
    @brief Format a list into sql.
    
    @param list    The list.
    """
    if list is None :
        return "null"
    else :
        return "ARRAY" + str(list)


def __str_to_array(text, delimiter):
    """
    @brief Get a array from text which is separated by delimiter
    
    @param text        The string which is separated by the delimiter.
    @param delimiter   The symbol that separates the text.    
    """
    if text is None or text == "" :
        return None
    
    array = str(text).lower().strip().split(delimiter)

    if len(array) == 0 :
        return None
    
    return [item.strip() for item in array]
        

def __column_exists(madlib_schema, full_table_name, column_name):
    """
    @brief Assert a column in the table whether exists.
    
    @param madlib_schema      The schema name.
    @param full_table_name    The table name.
    @param column_name        The column name.
    """
    __assert(
        full_table_name is not None and column_name is not None,
        "the table name and column name must not be null"
    )

    if __table_exists(madlib_schema, full_table_name) :
        curstmt = """
                  SELECT COUNT(*) AS count
                  FROM pg_catalog.pg_attribute
                  WHERE attnum > 0 AND
                      (NOT attisdropped)           AND
                      attname  = '{column_name}'   AND
                      attrelid = '{full_table_name}'::regclass
                  """.format(
                      column_name = column_name,
                      full_table_name = full_table_name
                  )
        t = plpy.execute(curstmt) 
        result = __get_query_value(t, "count")

        return result >= 1
    return False


def __table_exists(madlib_schema, validation_table_name):
    """
    @brief Assert whether a table exists.Invoke a udf which is 
           written in c.
    
    @param madlib_schema            The schema name.
    @param validation_table_name    The validated table name.   
    """
    t = plpy.execute(
            """
            SELECT {madlib_schema}.__table_exists
            (
                '{validation_table_name}'
            ) AS existence
            """.format(
                madlib_schema = madlib_schema, 
                validation_table_name = validation_table_name
            )
        )

    return __get_query_value(t, "existence")    
    

def __strip_schema_name(full_table_name):
    """
    @brief Get a brief name without schema. If the table name 
           contains a schema prefix, return the second part, 
           or return the name itself. 
    
    @param full_table_name    The table name
    """
    __assert(
        full_table_name is not None,
        "table name should not be null"
    )

    str_val_array = full_table_name.split(".")

    if len(str_val_array) == 1 :
        str_val = full_table_name
    elif len(str_val_array) == 2 :
        str_val = str_val_array[1]

    return str_val.lower()


def __assert(condition, reason):
    """
    @brief Assert, if the condition does not meet, raise an error with reanson 

    @param condition    The condition, a bool value.
    @param reason       The reason.
    """
    if (not condition):
        plpy.error(reason)


def __assert_table(madlib_schema, full_table_name, existence):
    """
    @brief Assert a table whether exists

    @param madlib_schema      The Schema name.
    @param full_table_name    The table name.
    @param existence          whether the table exists or not.
    """
    plpy.execute(
        """
        SELECT {madlib_schema}.__assert_table('{table_name}','{exist}')
        """.format(
            madlib_schema = madlib_schema,
            table_name = full_table_name,
            exist = existence
        )
    )


def __columns_in_table(
    madlib_schema,
    column_names,
    training_table_name
):
    """
    @brief Test if each element in the given array is a column of the table.
 
    @param column_names      The array containing the columns to be tested.
    @param table_name        The full table name.
 
    @return True if each element of column_names is a column of the table.
    """
    t = plpy.execute(
            """
            SELECT {madlib_schema}.__columns_in_table(
                {column_names},
                '{training_table_name}'
            ) AS existence
            """.format(
                madlib_schema = madlib_schema,
                column_names = __list_to_sql(column_names),
                training_table_name = training_table_name
            )
        )
    return __get_query_value(t, "existence")
