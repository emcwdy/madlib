/* ----------------------------------------------------------------------- *//** 
 *
 * @file dt_preproc.sql_in
 *
 * @brief Functions used in C4.5 and random forest for data preprocessing.
 *
 * @create    April 5, 2012
 * @modified  July 19, 2012
 *
 *//* ----------------------------------------------------------------------- */


m4_include(`SQLCommon.m4')

/* Own macro definitions */
m4_ifelse(
    m4_eval(
        m4_ifdef(`__GREENPLUM__', 1, 0) &&
        __DBMS_VERSION_MAJOR__ * 100 + __DBMS_VERSION_MINOR__ < 401
    ), 1,
    `m4_define(`__GREENPLUM_PRE_4_1__')'
)
m4_ifelse(
    m4_eval(
        m4_ifdef(`__POSTGRESQL__', 1, 0) &&
        __DBMS_VERSION_MAJOR__ < 9
    ), 1,
    `m4_define(`__POSTGRESQL_PRE_9_0__')'
)
m4_ifelse(
    m4_eval(
        m4_ifdef(`__GREENPLUM__', 1, 0) &&
        __DBMS_VERSION_MAJOR__ * 10000 +
            __DBMS_VERSION_MINOR__ * 100 +
            __DBMS_VERSION_PATCH__ >= 40201
    ), 1,
    `m4_define(`__GREENPLUM_GE_4_2_1__')'
)

/*
 * The file contains the functions to encode a training/classification table for 
 * C4.5 and random forest (RF). Given a training table, we encode it into 4 tables: 
 *     + A table that contains the distinct values and their assigned IDs for all
 *       features. We call it the Key-Value(KV) table for features.
 *     + A table that contains the distinct labels and their assigned IDs for the 
 *       class column. We call it the KV table for class.
 *     + A table that contains metadata descriptions about the columns of the training
 *       table. We call it the metatable.
 *     + A table that contains an encoded version of the training table using the 
 *       KV tables. We call it the encoded table.
 *
 * For a classification table, we only need the first three tables. We will use
 * Golf dataset as an example to illustrate the generated tables:
 *
 * testdb=# select * from golf order by id;
 *  id | outlook  | temperature | humidity | windy  |    class     
 * ----+----------+-------------+----------+--------+--------------
 *   1 | sunny    |          85 |       85 |  false |  Do not Play
 *   2 | sunny    |          80 |       90 |  true  |  Do not Play
 *   3 | overcast |          83 |       78 |  false |  Play
 *   4 | rain     |          70 |       96 |  false |  Play
 *   5 | rain     |          68 |       80 |  false |  Play
 *   6 | rain     |          65 |       70 |  true  |  Do not Play
 *   7 | overcast |          64 |       65 |  true  |  Play
 *   8 | sunny    |          72 |       95 |  false |  Do not Play
 *   9 | sunny    |          69 |       70 |  false |  Play
 *  10 | rain     |          75 |       80 |  false |  Play
 *  11 | sunny    |          75 |       70 |  true  |  Play
 *  12 | overcast |          72 |       90 |  true  |  Play
 *  13 | overcast |          81 |       75 |  false |  Play
 *  14 | rain     |          71 |       80 |  true  |  Do not Play
 * (14 rows)
 *
 *
 * The metatable contains the information of the columns in the training table.
 * For each column, it has a record whose structure is defined as:
 *
 *   +id             The ID assigned to a feature/class/id column. For the class 
 *                   colum,it's 0. To be determistic, the IDs for feature columns
 *                   starts at 1 and are assigned according to the alphabet order 
 *                   of the column names. The ID for the id column is the largest
 *                   feature ID plus one. 
 *   +column_name    The name of the class/feature/id column.
 *   +column_type    'c' means the column is a class. 
 *                   'f' means it's a feature column.
 *                   'i' means it's an id column.
 *   +is_cont        't' means the feature is continuous.
 *                   'f' means it's discrete.
 *   +table_oid      The OID of the KV table for features/class. 
 *                   For the id column, there is no KV table.
 *   +num_dist_value The number of distinct values for a feature/class column. 
 *
 * The metatable for the Golf dataset looks like this:
 * testdb=# select * from golf_meta order by id;
 *  id | column_name | column_type | is_cont | table_oid | num_dist_value 
 * ----+-------------+-------------+---------+-----------+----------------
 *   0 | class       | c           | f       |    787672 |              2
 *   1 | humidity    | f           | t       |    787749 |              9
 *   2 | outlook     | f           | f       |    787749 |              3
 *   3 | temperature | f           | t       |    787749 |             12
 *   4 | windy       | f           | f       |    787749 |              2
 *   5 | id          | i           | f       |           |              
 * (6 rows)
 * 
 * The KV table for features contains a record for each distinct value. The record
 * structure is:
 *   +fid      The ID assigned to a feature.
 *   +fval     For a discrete feature, it's the distinct value. 
 *             For a continuous feature, it's NULL.
 *   +code     For a discrete feature, it's the assigned key. 
 *             For a continuous feature, it's the average value.
 *
 * testdb=# select * from golf_kv_features order by fid, code;
 *  fid |   fval   |       code       
 * -----+----------+------------------
 *    1 |          | 80.2857142857143
 *    2 | overcast |                1
 *    2 | rain     |                2
 *    2 | sunny    |                3
 *    3 |          | 73.5714285714286
 *    4 | false    |                1
 *    4 | true     |                2
 * (7 rows)
 *
 * The KV table for class labels contains a record for each label. The record
 * structure is the same as the KV table for features.
 * testdb=# select * from golf_kv_class order by fid, code;
 *  fid |     fval     | code 
 * -----+--------------+------
 *    0 |  Do not Play |    1
 *    0 |  Play        |    2
 * 
 * The encoded table has a record for each cell in the training table. The record
 * structure is:
 *    +id       The ID from the training table. 
 *    +fid      The ID assigned to a feature
 *    +fval     For a discrete feature, it's the key. 
 *              For a continuous feature, it's the original feature value.
 *    +is_cont  't' if the feature is continuous, or 'f' for the discrete one.
 *    +class    The encoded value of the class label.
 * 
 * For Golf dataset, the vertical encoded table looks like this:
 * testdb=# select * from golf_ed order by fid, id;
 *  id | fid | fval | is_cont | class 
 * ----+-----+------+---------+-------
 *   1 |   1 |   85 | t       |     1
 *   2 |   1 |   90 | t       |     1
 *   3 |   1 |   78 | t       |     2
 *   4 |   1 |   96 | t       |     2
 *   5 |   1 |   80 | t       |     2
 *   6 |   1 |   70 | t       |     1
 *   7 |   1 |   65 | t       |     2
 *   8 |   1 |   95 | t       |     1
 *   9 |   1 |   70 | t       |     2
 *  10 |   1 |   80 | t       |     2
 *  11 |   1 |   70 | t       |     2
 *  12 |   1 |   90 | t       |     2
 *  13 |   1 |   75 | t       |     2
 *  14 |   1 |   80 | t       |     1
 *   1 |   2 |    3 | f       |     1
 *   2 |   2 |    3 | f       |     1
 *   3 |   2 |    1 | f       |     2
 *   4 |   2 |    2 | f       |     2
 *   5 |   2 |    2 | f       |     2
 *   6 |   2 |    2 | f       |     1
 *   7 |   2 |    1 | f       |     2
 *   8 |   2 |    3 | f       |     1
 *   9 |   2 |    3 | f       |     2
 *  10 |   2 |    2 | f       |     2
 *  11 |   2 |    3 | f       |     2
 *  12 |   2 |    1 | f       |     2
 *  13 |   2 |    1 | f       |     2
 *  14 |   2 |    2 | f       |     1
 *   1 |   3 |   85 | t       |     1
 *   2 |   3 |   80 | t       |     1
 *   3 |   3 |   83 | t       |     2
 *   4 |   3 |   70 | t       |     2
 *   5 |   3 |   68 | t       |     2
 *   6 |   3 |   65 | t       |     1
 *   7 |   3 |   64 | t       |     2
 *   8 |   3 |   72 | t       |     1
 *   9 |   3 |   69 | t       |     2
 *  10 |   3 |   75 | t       |     2
 *  11 |   3 |   75 | t       |     2
 *  12 |   3 |   72 | t       |     2
 *  13 |   3 |   81 | t       |     2
 *  14 |   3 |   71 | t       |     1
 *   1 |   4 |    1 | f       |     1
 *   2 |   4 |    2 | f       |     1
 *   3 |   4 |    1 | f       |     2
 *   4 |   4 |    1 | f       |     2
 *   5 |   4 |    1 | f       |     2
 *   6 |   4 |    2 | f       |     1
 *   7 |   4 |    2 | f       |     2
 *   8 |   4 |    1 | f       |     1
 *   9 |   4 |    1 | f       |     2
 *  10 |   4 |    1 | f       |     2
 *  11 |   4 |    2 | f       |     2
 *  12 |   4 |    2 | f       |     2
 *  13 |   4 |    1 | f       |     2
 *  14 |   4 |    2 | f       |     1
 * (56 rows)
 *
 * On databases that support compression, we can leverage that feature
 * to reduce the space required for keeping the encoded table.
 *
 * For classification, we will use the metatable and KV tables to encode 
 * the table (horizontal table) to be classified into some like this: 
 *
 * testdb# select * from golf_ed order by id;
 *  id |    fvals    | class 
 * ----+-------------+-------
 *   1 | {85,3,85,1} |     1
 *   2 | {90,3,80,2} |     1
 *   3 | {78,1,83,1} |     2
 *   4 | {96,2,70,1} |     2
 *   5 | {80,2,68,1} |     2
 *   6 | {70,2,65,2} |     1
 *   7 | {65,1,64,2} |     2
 *   8 | {95,3,72,1} |     1
 *   9 | {70,3,69,1} |     2
 *  10 | {80,2,75,1} |     2
 *  11 | {70,3,75,2} |     2
 *  12 | {90,1,72,2} |     2
 *  13 | {75,1,81,1} |     2
 *  14 | {80,2,71,2} |     1
 * (14 rows)
 *
 * In general, each record in the new encoded table has the following structure:
 *    +id     The ID from the classification table.
 *    +fvals  An array contains all the features' values for a given ID.
 *            For a discrete feature, the element in the array is the key.
 *            For a continuous feature, it's the original value.
 *    +class  The encoded value of a class label.
 *
 */


/*
 * The UDT for keeping the time for each step of the encoding procedure.
 *
 *      pre_proc_time            The time of pre-processing.
 *      breakup_tbl_time         The time of breaking up the training table.
 *      gen_kv_time              The time of generating KV-table for 
 *                               features/class. 
 *      gen_enc_time             The time of generating encoded table.
 *      post_proc_time           The time of post-processing.
 *
 */
DROP TYPE IF EXISTS MADLIB_SCHEMA.__enc_tbl_result;
CREATE TYPE MADLIB_SCHEMA.__enc_tbl_result AS 
(     
    pre_proc_time            INTERVAL,
    breakup_tbl_time         INTERVAL,
    gen_kv_time              INTERVAL,
    gen_enc_time             INTERVAL,
    post_proc_time           INTERVAL
);


/*
 * @brief Check if the input table has unsupported data type or not.
 *        Check if the id column of input table has duplicated value or not.
 *
 * @param full_table_name     The full table name.
 * @param feature_columns     The array including all feature names.
 * @param id_column           The name of the ID column.        
 * @param class_column        The name of the class column. 
 *
 * @return If the table has unsupported data types, then raise exception
 *         otherwise return nothing.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__validate_input_table    
    (
    full_table_name     TEXT,
    feature_columns     TEXT[],
    id_column           TEXT,
    class_column        TEXT
    )
RETURNS void AS $$  
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    dt_preproc.__validate_input_table(MADlibSchema, full_table_name, feature_columns, id_column, class_column)
$$ LANGUAGE PLPYTHONU;    


/*
 * @brief Get the class table name by the metatable name.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The name of the class table
 *
 */  
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_classtable_name
    (
    meta_tbl_name TEXT 
    ) 
RETURNS TEXT AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')
    
    return dt_preproc.__get_classtable_name(MADlibSchema, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Drop the metatable and KV tables 
 *        for the features and the class.
 *
 * @param meta_tbl_name The full name of the metatable.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__drop_metatable 
    (
    meta_tbl_name TEXT
    )
RETURNS void AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')
 
    dt_preproc.__drop_metatable(MADlibSchema, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Create the metatable.
 
 * @param meta_tbl_name    The full name of the metatable.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_metatable 
    (
    meta_tbl_name TEXT
    )
RETURNS void AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')
 
    dt_preproc.__create_metatable(MADlibSchema, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Insert a record to the metatable
 *        A row in the metatable represents a column's information.
 *
 * @param meta_tbl_name     The full name of the metatable.
 * @param column_name       The name of the column.
 * @param column_type       The type of the column.
 *                          'i' means id, 'c' means class, 'f' means feature.
 * @param is_cont           True if the column is continuous.
 * @param table_name        The full name of key-value table for the column.
 *                          The OID of this table will be stored.
 * @param num_dist_value    The number of distinct values for the column.
 *
 * @note  The null value will be included in the distinct values.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_metatable 
    (
    meta_tbl_name       TEXT,
    col_index           INT,
    column_name         TEXT,
    column_type         CHAR,   
    is_cont             BOOLEAN,     
    table_name          TEXT,
    num_dist_value      INT         
    )
RETURNS void AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    dt_preproc.__insert_into_metatable(MADlibSchema, meta_tbl_name, col_index,
                   column_name, column_type, is_cont, table_name, num_dist_value)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Validate if the metatable exists or not.
 *        Validate if the tables in "table_oid" column exists or not.
 *
 * @param meta_tbl_name     The full name of the metatable.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__validate_metatable 
    (
    meta_tbl_name TEXT
    )
RETURNS VOID AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    dt_preproc.__validate_metatable(MADlibSchema, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;

/*
 * @brief Get the number of distinct values for the feature with given ID.
 *
 * @param meta_tbl_name     The full name of the metatable.
 * @param feature_id        The ID of the feature in the metatable.
 *
 * @return The number of the distinct values for the given feature.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__distinct_feature_value 
    (
    meta_tbl_name   TEXT,
    feature_id      INT
    )
RETURNS INT4 AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    return dt_preproc.__distinct_feature_value(MADlibSchema, meta_tbl_name, feature_id)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Get the number of features.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The number of features in the training table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_feature 
    (
    meta_tbl_name TEXT
    )
RETURNS INT4 AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    return dt_preproc.__num_of_feature(MADlibSchema, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Get the number of distinct class values.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The number of class labels in the training table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_class
    (
    meta_tbl_name TEXT
    )
RETURNS INT4 AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    return dt_preproc.__num_of_class(MADlibSchema, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Get the feature name by the specified feature ID.
 *
 * @param feature_index     The ID of the feature.
 * @param meta_tbl_name     The full name of the metatable.
 *
 * @return The feature name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name    
    (
    feature_index   INT,
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    return dt_preproc.__get_feature_name(MADlibSchema, feature_index, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Get the column value by the specified column ID and code.
 *
 * @param column_index      The ID of the column.
 * @param code              The code of the column value.
 * @param column_type       The type of the column.
 *                          'i' means id, 'c' means class, 'f' means feature.
 * @param meta_tbl_name     The full name of the metatable.
 * 
 * @return The column's value corresponding to the give code. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_column_value    
    (
    column_index    INT,
    code            INT,
    column_type     CHAR,
    meta_tbl_name   TEXT
    )
RETURNS TEXT AS $$  
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    return dt_preproc.__get_column_value(MADlibSchema, column_index, code, column_type, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Get the feature value by the specified feature ID and code.
 *
 * @param feature_index     The ID of the feature.
 * @param code              The code of the feature value.
 * @param meta_tbl_name     The full name of the metatable.  
 *
 * @return The value of specified code of the feature 
 *         whose id specified in feature_index.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_value    
    (
    feature_index   INT,
    code            INT,
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$  
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    return dt_preproc.__get_feature_value(MADlibSchema, feature_index, code, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Get the ID column name.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The ID column name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_id_column_name    
    (
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    return dt_preproc.__get_id_column_name(MADlibSchema, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Get the class column name.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The class column name. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_column_name    
    (
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    return dt_preproc.__get_class_column_name(MADlibSchema, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Get the class value by the specified code.
 *
 * @param code               The code of the class value.
 * @param meta_tbl_name      The full name of the metatable.
 *
 * @return The class value corresponding to the code. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_value    
    (
    code            INT,
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$  
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    return dt_preproc.__get_class_value(MADlibSchema, code, meta_tbl_name)
$$ LANGUAGE PLPYTHONU;  


/*
 * @brief breakup each record from the training table.
 *        For example, we have the training table t(id, f1, f2, f3, class), 
 *        then the breakup table is bt(id, fid, fval, is_cont, class). 
 *        The id column of the two tables is the same. Each feature will be
 *        encoded to continuous numeric number. Assume that t has values
 *          (1, 'a', 1, 10, '+') 
 *          (2, 'b', 2, 8, '-')
 *          (3, 'd', null, 2, '+') 
 *        and all of them are discrete features, then the values of bt are 
 *          (1, 1, 'a', 'f', '+') 
 *          (2, 1, 'b', 'f', '-') 
 *          (3, 1, 'd', 'f', '+')
 *          (1, 2, 1, 'f', '+') 
 *          (2, 2, 2, 'f', '-') 
 *          (3, 2, null, 'f', '+')
 *          (1, 3, 10, 'f', '+') 
 *          (2, 3, 8, 'f', '-') 
 *          (3, 3, 2, 'f', '+')
 *
 * @param input_tbl_name      The full name of the input training table.
 * @param breakup_tbl_name    The name of the breakup table.
 * @param kv_cls_name         The name of the key-value table for class column.
 * @param id_col_name         The name of the ID column. 
 * @param attr_col_names      The array contains all the features' names.
 * @param is_conts            The subscript of the array denotes the feature index.
 *                            Each value of the array denotes the feature is
 *                            continuous ('t') or discrete ('f')
 * @param verbosity           > 0 means this function runs in verbose mode. 
 *
 * @return The name of the breakup table, which will be used to generate the encoded
 *         table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__breakup_table
    (
    input_tbl_name        TEXT, 
    breakup_tbl_name      TEXT,
    kv_cls_name           TEXT,
    id_col_name           TEXT,
    cls_col_name          TEXT,
    attr_col_names        TEXT[],
    is_conts              BOOL[],
    h2hmv_routine_id      INT,
    verbosity             INT
    ) 
RETURNS VOID AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    dt_preproc.__breakup_table(MADlibSchema, input_tbl_name, breakup_tbl_name, 
                  kv_cls_name, id_col_name, cls_col_name, attr_col_names, 
                  is_conts, h2hmv_routine_id, verbosity)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Generate the vertical encoded table from the breakup table.
 *
 * @param breakup_tbl_name    The full name of the breakup table.
 * @param enc_tbl_name        The name of the encoded table. its schema is:
 *                              id BIGINT, 
 *                              fid INT, 
 *                              fval FLOAT8, 
 *                              is_cont BOOL, 
 *                              class INT
 * @param kv_attr_name        The name of the key-value table contains the encoded
 *                            result for all the features. For continuous feature,
 *                            it kept the average value of it if in 'explicit' mode;
 *                            nothing will kept if in 'ignore' mode.
 * @param is_tbl_tmp          If ture we will create the encoded table as a temp one.
 * @param verbosity           > 0 means this function runs in verbose mode. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__gen_vertical_encoded_table
    (
    breakup_tbl_name      TEXT,     
    enc_tbl_name          TEXT,
    kv_attr_name          TEXT,
    is_tbl_tmp            BOOL,
    verbosity             INT
    ) 
RETURNS VOID AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    dt_preproc.__gen_vertical_encoded_table(MADlibSchema, breakup_tbl_name, enc_tbl_name,
                   kv_attr_name, is_tbl_tmp, verbosity)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Generate the horizontal table from a given vertical table.
 *
 * @param hor_tbl_name          The full name of the horizontal table.
 * @param ver_tbl_name          The full name of the vertical table.
 * @param meta_tbl_name         The full name of the meta data table.
 * @param verbosity             > 0 means this function runs in verbose mode. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__gen_horizontal_encoded_table
    (
    hor_tbl_name        TEXT,
    ver_tbl_name        TEXT,
    attr_count          INT,
    verbosity           INT
    ) 
RETURNS VOID AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    dt_preproc.__gen_horizontal_encoded_table(MADlibSchema, hor_tbl_name, ver_tbl_name, attr_count, verbosity)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Encode the continuous and discrete features and the class column.
 *        In 'ignore' mode, for each discrete feature/class, we will use 
 *        continuous integer to encode each distinct value (null value 
 *        will be excluded). Continuous feature will not be processed. 
 *        In 'explicit' mode, null value will be included for discrete 
 *        feature. For continuous feature, null value will be replaced by
 *        the average value of this feature.
 * 
 * @param kv_attr_name        The name of the key-value table contains the encoded
 *                            result for all the features. For continuous feature,
 *                            it kept the average value of it if in 'explicit' mode;
 *                            nothing will kept if in 'ignore' mode.
 * @param breakup_tbl_name    The name of the breakup table from raw training table.
 * @param h2hmv_routine_id    The ID of the routine which specifies 
 *                            How to handle missing value(h2hmv).
 * @param verbosity           > 0 means this function runs in verbose mode.
 *
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_columns
    (
    kv_attr_name        TEXT,
    breakup_tbl_name    TEXT,
    h2hmv_routine_id    INT,
    verbosity           INT
    )
RETURNS VOID AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')
 
    dt_preproc.__encode_columns(MADlibSchema, kv_attr_name, breakup_tbl_name, h2hmv_routine_id, verbosity)
$$ LANGUAGE PLPYTHONU;


/*
 * @brief Encode a table for training in C4.5 and RF.
 *
 * @param input_tbl_name      The full name of the input table.
 * @param id_col_name         The name of id column.
 * @param feature_names       An array contains all the feature. If it's null, 
 *                            we will get all the columns of the input table.
 * @param cls_col_name        The name of class column.
 * @param cont_attr_names     An array contains all the continuous feature.
 *                            Null means no continuous feature.
 * @param enc_table_name      The full name of the encoded table.
 * @param meta_tbl_name       The full name of the metatable.
 * @param h2hmv_routine_id    The ID of the routine which specifies 
 *                            How to handle missing value(h2hmv).
 * @param verbosity           > 0 means this function runs in verbose mode. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_table
    (
    input_tbl_name      TEXT, 
    id_col_name         TEXT, 
    feature_names       TEXT[],
    cls_col_name        TEXT, 
    cont_attr_names     TEXT[], 
    enc_table_name      TEXT,
    meta_tbl_name       TEXT,
    h2hmv_routine_id    INT,
    verbosity           INT
    ) 
RETURNS VOID AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    dt_preproc.__encode_table_training(MADlibSchema, input_tbl_name, id_col_name, feature_names,
                   cls_col_name, cont_attr_names, enc_table_name, meta_tbl_name, h2hmv_routine_id, verbosity)
$$ LANGUAGE PLPYTHONU;  


/*
 * @brief Encode a table for classification/scoring.
 *
 * @param input_tbl_name        The full name of the input table.
 * @param enc_tbl_name          The full name of the encoded table.
 * @param meta_tbl_name         The full name of the metatable.
 * @param h2hmv_routine_id      The ID of the routine which specifies 
 *                              how to handle missing value(h2hmv). 
 * @param verbosity             > 0 means this function runs in verbose mode. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_table
    (
    input_tbl_name      TEXT, 
    enc_tbl_name        TEXT,
    meta_tbl_name       TEXT,
    h2hmv_routine_id    INT,
    verbosity           INT
    ) 
RETURNS VOID AS $$
    PythonFunctionBodyOnly(`cart', `dt_preproc')

    dt_preproc.__encode_table_classify(MADlibSchema, input_tbl_name, enc_tbl_name, meta_tbl_name, h2hmv_routine_id, verbosity)
$$ LANGUAGE PLPYTHONU;
